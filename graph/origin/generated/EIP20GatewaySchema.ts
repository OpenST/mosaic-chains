// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Address,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts/index";

export class StakeIntentDeclared extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save StakeIntentDeclared entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save StakeIntentDeclared entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("StakeIntentDeclared", id.toString(), this);
  }

  static load(id: string): StakeIntentDeclared | null {
    return store.get("StakeIntentDeclared", id) as StakeIntentDeclared | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _messageHash(): Bytes {
    let value = this.get("_messageHash");
    return value.toBytes();
  }

  set _messageHash(value: Bytes) {
    this.set("_messageHash", Value.fromBytes(value));
  }

  get _staker(): Bytes {
    let value = this.get("_staker");
    return value.toBytes();
  }

  set _staker(value: Bytes) {
    this.set("_staker", Value.fromBytes(value));
  }

  get _stakerNonce(): BigInt {
    let value = this.get("_stakerNonce");
    return value.toBigInt();
  }

  set _stakerNonce(value: BigInt) {
    this.set("_stakerNonce", Value.fromBigInt(value));
  }

  get _beneficiary(): Bytes {
    let value = this.get("_beneficiary");
    return value.toBytes();
  }

  set _beneficiary(value: Bytes) {
    this.set("_beneficiary", Value.fromBytes(value));
  }

  get _amount(): BigInt {
    let value = this.get("_amount");
    return value.toBigInt();
  }

  set _amount(value: BigInt) {
    this.set("_amount", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockHash(): Bytes {
    let value = this.get("blockHash");
    return value.toBytes();
  }

  set blockHash(value: Bytes) {
    this.set("blockHash", Value.fromBytes(value));
  }

  get contractAddress(): Bytes {
    let value = this.get("contractAddress");
    return value.toBytes();
  }

  set contractAddress(value: Bytes) {
    this.set("contractAddress", Value.fromBytes(value));
  }

  get uts(): BigInt {
    let value = this.get("uts");
    return value.toBigInt();
  }

  set uts(value: BigInt) {
    this.set("uts", Value.fromBigInt(value));
  }
}

export class StakeProgressed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save StakeProgressed entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save StakeProgressed entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("StakeProgressed", id.toString(), this);
  }

  static load(id: string): StakeProgressed | null {
    return store.get("StakeProgressed", id) as StakeProgressed | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _messageHash(): Bytes {
    let value = this.get("_messageHash");
    return value.toBytes();
  }

  set _messageHash(value: Bytes) {
    this.set("_messageHash", Value.fromBytes(value));
  }

  get _staker(): Bytes {
    let value = this.get("_staker");
    return value.toBytes();
  }

  set _staker(value: Bytes) {
    this.set("_staker", Value.fromBytes(value));
  }

  get _stakerNonce(): BigInt {
    let value = this.get("_stakerNonce");
    return value.toBigInt();
  }

  set _stakerNonce(value: BigInt) {
    this.set("_stakerNonce", Value.fromBigInt(value));
  }

  get _amount(): BigInt {
    let value = this.get("_amount");
    return value.toBigInt();
  }

  set _amount(value: BigInt) {
    this.set("_amount", Value.fromBigInt(value));
  }

  get _proofProgress(): boolean {
    let value = this.get("_proofProgress");
    return value.toBoolean();
  }

  set _proofProgress(value: boolean) {
    this.set("_proofProgress", Value.fromBoolean(value));
  }

  get _unlockSecret(): Bytes {
    let value = this.get("_unlockSecret");
    return value.toBytes();
  }

  set _unlockSecret(value: Bytes) {
    this.set("_unlockSecret", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockHash(): Bytes {
    let value = this.get("blockHash");
    return value.toBytes();
  }

  set blockHash(value: Bytes) {
    this.set("blockHash", Value.fromBytes(value));
  }

  get contractAddress(): Bytes {
    let value = this.get("contractAddress");
    return value.toBytes();
  }

  set contractAddress(value: Bytes) {
    this.set("contractAddress", Value.fromBytes(value));
  }

  get uts(): BigInt {
    let value = this.get("uts");
    return value.toBigInt();
  }

  set uts(value: BigInt) {
    this.set("uts", Value.fromBigInt(value));
  }
}

export class RevertStakeIntentDeclared extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save RevertStakeIntentDeclared entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save RevertStakeIntentDeclared entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("RevertStakeIntentDeclared", id.toString(), this);
  }

  static load(id: string): RevertStakeIntentDeclared | null {
    return store.get(
      "RevertStakeIntentDeclared",
      id
    ) as RevertStakeIntentDeclared | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _messageHash(): Bytes {
    let value = this.get("_messageHash");
    return value.toBytes();
  }

  set _messageHash(value: Bytes) {
    this.set("_messageHash", Value.fromBytes(value));
  }

  get _staker(): Bytes {
    let value = this.get("_staker");
    return value.toBytes();
  }

  set _staker(value: Bytes) {
    this.set("_staker", Value.fromBytes(value));
  }

  get _stakerNonce(): BigInt {
    let value = this.get("_stakerNonce");
    return value.toBigInt();
  }

  set _stakerNonce(value: BigInt) {
    this.set("_stakerNonce", Value.fromBigInt(value));
  }

  get _amount(): BigInt {
    let value = this.get("_amount");
    return value.toBigInt();
  }

  set _amount(value: BigInt) {
    this.set("_amount", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockHash(): Bytes {
    let value = this.get("blockHash");
    return value.toBytes();
  }

  set blockHash(value: Bytes) {
    this.set("blockHash", Value.fromBytes(value));
  }

  get contractAddress(): Bytes {
    let value = this.get("contractAddress");
    return value.toBytes();
  }

  set contractAddress(value: Bytes) {
    this.set("contractAddress", Value.fromBytes(value));
  }

  get uts(): BigInt {
    let value = this.get("uts");
    return value.toBigInt();
  }

  set uts(value: BigInt) {
    this.set("uts", Value.fromBigInt(value));
  }
}

export class StakeReverted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save StakeReverted entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save StakeReverted entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("StakeReverted", id.toString(), this);
  }

  static load(id: string): StakeReverted | null {
    return store.get("StakeReverted", id) as StakeReverted | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _messageHash(): Bytes {
    let value = this.get("_messageHash");
    return value.toBytes();
  }

  set _messageHash(value: Bytes) {
    this.set("_messageHash", Value.fromBytes(value));
  }

  get _staker(): Bytes {
    let value = this.get("_staker");
    return value.toBytes();
  }

  set _staker(value: Bytes) {
    this.set("_staker", Value.fromBytes(value));
  }

  get _stakerNonce(): BigInt {
    let value = this.get("_stakerNonce");
    return value.toBigInt();
  }

  set _stakerNonce(value: BigInt) {
    this.set("_stakerNonce", Value.fromBigInt(value));
  }

  get _amount(): BigInt {
    let value = this.get("_amount");
    return value.toBigInt();
  }

  set _amount(value: BigInt) {
    this.set("_amount", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockHash(): Bytes {
    let value = this.get("blockHash");
    return value.toBytes();
  }

  set blockHash(value: Bytes) {
    this.set("blockHash", Value.fromBytes(value));
  }

  get contractAddress(): Bytes {
    let value = this.get("contractAddress");
    return value.toBytes();
  }

  set contractAddress(value: Bytes) {
    this.set("contractAddress", Value.fromBytes(value));
  }

  get uts(): BigInt {
    let value = this.get("uts");
    return value.toBigInt();
  }

  set uts(value: BigInt) {
    this.set("uts", Value.fromBigInt(value));
  }
}

export class RedeemIntentConfirmed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save RedeemIntentConfirmed entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save RedeemIntentConfirmed entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("RedeemIntentConfirmed", id.toString(), this);
  }

  static load(id: string): RedeemIntentConfirmed | null {
    return store.get(
      "RedeemIntentConfirmed",
      id
    ) as RedeemIntentConfirmed | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _messageHash(): Bytes {
    let value = this.get("_messageHash");
    return value.toBytes();
  }

  set _messageHash(value: Bytes) {
    this.set("_messageHash", Value.fromBytes(value));
  }

  get _redeemer(): Bytes {
    let value = this.get("_redeemer");
    return value.toBytes();
  }

  set _redeemer(value: Bytes) {
    this.set("_redeemer", Value.fromBytes(value));
  }

  get _redeemerNonce(): BigInt {
    let value = this.get("_redeemerNonce");
    return value.toBigInt();
  }

  set _redeemerNonce(value: BigInt) {
    this.set("_redeemerNonce", Value.fromBigInt(value));
  }

  get _beneficiary(): Bytes {
    let value = this.get("_beneficiary");
    return value.toBytes();
  }

  set _beneficiary(value: Bytes) {
    this.set("_beneficiary", Value.fromBytes(value));
  }

  get _amount(): BigInt {
    let value = this.get("_amount");
    return value.toBigInt();
  }

  set _amount(value: BigInt) {
    this.set("_amount", Value.fromBigInt(value));
  }

  get _blockHeight(): BigInt {
    let value = this.get("_blockHeight");
    return value.toBigInt();
  }

  set _blockHeight(value: BigInt) {
    this.set("_blockHeight", Value.fromBigInt(value));
  }

  get _hashLock(): Bytes {
    let value = this.get("_hashLock");
    return value.toBytes();
  }

  set _hashLock(value: Bytes) {
    this.set("_hashLock", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockHash(): Bytes {
    let value = this.get("blockHash");
    return value.toBytes();
  }

  set blockHash(value: Bytes) {
    this.set("blockHash", Value.fromBytes(value));
  }

  get contractAddress(): Bytes {
    let value = this.get("contractAddress");
    return value.toBytes();
  }

  set contractAddress(value: Bytes) {
    this.set("contractAddress", Value.fromBytes(value));
  }

  get uts(): BigInt {
    let value = this.get("uts");
    return value.toBigInt();
  }

  set uts(value: BigInt) {
    this.set("uts", Value.fromBigInt(value));
  }
}

export class UnstakeProgressed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save UnstakeProgressed entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save UnstakeProgressed entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("UnstakeProgressed", id.toString(), this);
  }

  static load(id: string): UnstakeProgressed | null {
    return store.get("UnstakeProgressed", id) as UnstakeProgressed | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _messageHash(): Bytes {
    let value = this.get("_messageHash");
    return value.toBytes();
  }

  set _messageHash(value: Bytes) {
    this.set("_messageHash", Value.fromBytes(value));
  }

  get _redeemer(): Bytes {
    let value = this.get("_redeemer");
    return value.toBytes();
  }

  set _redeemer(value: Bytes) {
    this.set("_redeemer", Value.fromBytes(value));
  }

  get _beneficiary(): Bytes {
    let value = this.get("_beneficiary");
    return value.toBytes();
  }

  set _beneficiary(value: Bytes) {
    this.set("_beneficiary", Value.fromBytes(value));
  }

  get _redeemAmount(): BigInt {
    let value = this.get("_redeemAmount");
    return value.toBigInt();
  }

  set _redeemAmount(value: BigInt) {
    this.set("_redeemAmount", Value.fromBigInt(value));
  }

  get _unstakeAmount(): BigInt {
    let value = this.get("_unstakeAmount");
    return value.toBigInt();
  }

  set _unstakeAmount(value: BigInt) {
    this.set("_unstakeAmount", Value.fromBigInt(value));
  }

  get _rewardAmount(): BigInt {
    let value = this.get("_rewardAmount");
    return value.toBigInt();
  }

  set _rewardAmount(value: BigInt) {
    this.set("_rewardAmount", Value.fromBigInt(value));
  }

  get _proofProgress(): boolean {
    let value = this.get("_proofProgress");
    return value.toBoolean();
  }

  set _proofProgress(value: boolean) {
    this.set("_proofProgress", Value.fromBoolean(value));
  }

  get _unlockSecret(): Bytes {
    let value = this.get("_unlockSecret");
    return value.toBytes();
  }

  set _unlockSecret(value: Bytes) {
    this.set("_unlockSecret", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockHash(): Bytes {
    let value = this.get("blockHash");
    return value.toBytes();
  }

  set blockHash(value: Bytes) {
    this.set("blockHash", Value.fromBytes(value));
  }

  get contractAddress(): Bytes {
    let value = this.get("contractAddress");
    return value.toBytes();
  }

  set contractAddress(value: Bytes) {
    this.set("contractAddress", Value.fromBytes(value));
  }

  get uts(): BigInt {
    let value = this.get("uts");
    return value.toBigInt();
  }

  set uts(value: BigInt) {
    this.set("uts", Value.fromBigInt(value));
  }
}

export class RevertRedeemIntentConfirmed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save RevertRedeemIntentConfirmed entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save RevertRedeemIntentConfirmed entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("RevertRedeemIntentConfirmed", id.toString(), this);
  }

  static load(id: string): RevertRedeemIntentConfirmed | null {
    return store.get(
      "RevertRedeemIntentConfirmed",
      id
    ) as RevertRedeemIntentConfirmed | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _messageHash(): Bytes {
    let value = this.get("_messageHash");
    return value.toBytes();
  }

  set _messageHash(value: Bytes) {
    this.set("_messageHash", Value.fromBytes(value));
  }

  get _redeemer(): Bytes {
    let value = this.get("_redeemer");
    return value.toBytes();
  }

  set _redeemer(value: Bytes) {
    this.set("_redeemer", Value.fromBytes(value));
  }

  get _redeemerNonce(): BigInt {
    let value = this.get("_redeemerNonce");
    return value.toBigInt();
  }

  set _redeemerNonce(value: BigInt) {
    this.set("_redeemerNonce", Value.fromBigInt(value));
  }

  get _amount(): BigInt {
    let value = this.get("_amount");
    return value.toBigInt();
  }

  set _amount(value: BigInt) {
    this.set("_amount", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockHash(): Bytes {
    let value = this.get("blockHash");
    return value.toBytes();
  }

  set blockHash(value: Bytes) {
    this.set("blockHash", Value.fromBytes(value));
  }

  get contractAddress(): Bytes {
    let value = this.get("contractAddress");
    return value.toBytes();
  }

  set contractAddress(value: Bytes) {
    this.set("contractAddress", Value.fromBytes(value));
  }

  get uts(): BigInt {
    let value = this.get("uts");
    return value.toBigInt();
  }

  set uts(value: BigInt) {
    this.set("uts", Value.fromBigInt(value));
  }
}

export class RevertRedeemComplete extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save RevertRedeemComplete entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save RevertRedeemComplete entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("RevertRedeemComplete", id.toString(), this);
  }

  static load(id: string): RevertRedeemComplete | null {
    return store.get("RevertRedeemComplete", id) as RevertRedeemComplete | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _messageHash(): Bytes {
    let value = this.get("_messageHash");
    return value.toBytes();
  }

  set _messageHash(value: Bytes) {
    this.set("_messageHash", Value.fromBytes(value));
  }

  get _redeemer(): Bytes {
    let value = this.get("_redeemer");
    return value.toBytes();
  }

  set _redeemer(value: Bytes) {
    this.set("_redeemer", Value.fromBytes(value));
  }

  get _redeemerNonce(): BigInt {
    let value = this.get("_redeemerNonce");
    return value.toBigInt();
  }

  set _redeemerNonce(value: BigInt) {
    this.set("_redeemerNonce", Value.fromBigInt(value));
  }

  get _amount(): BigInt {
    let value = this.get("_amount");
    return value.toBigInt();
  }

  set _amount(value: BigInt) {
    this.set("_amount", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockHash(): Bytes {
    let value = this.get("blockHash");
    return value.toBytes();
  }

  set blockHash(value: Bytes) {
    this.set("blockHash", Value.fromBytes(value));
  }

  get contractAddress(): Bytes {
    let value = this.get("contractAddress");
    return value.toBytes();
  }

  set contractAddress(value: Bytes) {
    this.set("contractAddress", Value.fromBytes(value));
  }

  get uts(): BigInt {
    let value = this.get("uts");
    return value.toBigInt();
  }

  set uts(value: BigInt) {
    this.set("uts", Value.fromBigInt(value));
  }
}

export class GatewayProven extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save GatewayProven entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save GatewayProven entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("GatewayProven", id.toString(), this);
  }

  static load(id: string): GatewayProven | null {
    return store.get("GatewayProven", id) as GatewayProven | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _gateway(): Bytes {
    let value = this.get("_gateway");
    return value.toBytes();
  }

  set _gateway(value: Bytes) {
    this.set("_gateway", Value.fromBytes(value));
  }

  get _blockHeight(): BigInt {
    let value = this.get("_blockHeight");
    return value.toBigInt();
  }

  set _blockHeight(value: BigInt) {
    this.set("_blockHeight", Value.fromBigInt(value));
  }

  get _storageRoot(): Bytes {
    let value = this.get("_storageRoot");
    return value.toBytes();
  }

  set _storageRoot(value: Bytes) {
    this.set("_storageRoot", Value.fromBytes(value));
  }

  get _wasAlreadyProved(): boolean {
    let value = this.get("_wasAlreadyProved");
    return value.toBoolean();
  }

  set _wasAlreadyProved(value: boolean) {
    this.set("_wasAlreadyProved", Value.fromBoolean(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockHash(): Bytes {
    let value = this.get("blockHash");
    return value.toBytes();
  }

  set blockHash(value: Bytes) {
    this.set("blockHash", Value.fromBytes(value));
  }

  get contractAddress(): Bytes {
    let value = this.get("contractAddress");
    return value.toBytes();
  }

  set contractAddress(value: Bytes) {
    this.set("contractAddress", Value.fromBytes(value));
  }

  get uts(): BigInt {
    let value = this.get("uts");
    return value.toBigInt();
  }

  set uts(value: BigInt) {
    this.set("uts", Value.fromBigInt(value));
  }
}

export class BountyChangeInitiated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save BountyChangeInitiated entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save BountyChangeInitiated entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("BountyChangeInitiated", id.toString(), this);
  }

  static load(id: string): BountyChangeInitiated | null {
    return store.get(
      "BountyChangeInitiated",
      id
    ) as BountyChangeInitiated | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _currentBounty(): BigInt {
    let value = this.get("_currentBounty");
    return value.toBigInt();
  }

  set _currentBounty(value: BigInt) {
    this.set("_currentBounty", Value.fromBigInt(value));
  }

  get _proposedBounty(): BigInt {
    let value = this.get("_proposedBounty");
    return value.toBigInt();
  }

  set _proposedBounty(value: BigInt) {
    this.set("_proposedBounty", Value.fromBigInt(value));
  }

  get _unlockHeight(): BigInt {
    let value = this.get("_unlockHeight");
    return value.toBigInt();
  }

  set _unlockHeight(value: BigInt) {
    this.set("_unlockHeight", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockHash(): Bytes {
    let value = this.get("blockHash");
    return value.toBytes();
  }

  set blockHash(value: Bytes) {
    this.set("blockHash", Value.fromBytes(value));
  }

  get contractAddress(): Bytes {
    let value = this.get("contractAddress");
    return value.toBytes();
  }

  set contractAddress(value: Bytes) {
    this.set("contractAddress", Value.fromBytes(value));
  }

  get uts(): BigInt {
    let value = this.get("uts");
    return value.toBigInt();
  }

  set uts(value: BigInt) {
    this.set("uts", Value.fromBigInt(value));
  }
}

export class BountyChangeConfirmed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save BountyChangeConfirmed entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save BountyChangeConfirmed entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("BountyChangeConfirmed", id.toString(), this);
  }

  static load(id: string): BountyChangeConfirmed | null {
    return store.get(
      "BountyChangeConfirmed",
      id
    ) as BountyChangeConfirmed | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _currentBounty(): BigInt {
    let value = this.get("_currentBounty");
    return value.toBigInt();
  }

  set _currentBounty(value: BigInt) {
    this.set("_currentBounty", Value.fromBigInt(value));
  }

  get _changedBounty(): BigInt {
    let value = this.get("_changedBounty");
    return value.toBigInt();
  }

  set _changedBounty(value: BigInt) {
    this.set("_changedBounty", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockHash(): Bytes {
    let value = this.get("blockHash");
    return value.toBytes();
  }

  set blockHash(value: Bytes) {
    this.set("blockHash", Value.fromBytes(value));
  }

  get contractAddress(): Bytes {
    let value = this.get("contractAddress");
    return value.toBytes();
  }

  set contractAddress(value: Bytes) {
    this.set("contractAddress", Value.fromBytes(value));
  }

  get uts(): BigInt {
    let value = this.get("uts");
    return value.toBigInt();
  }

  set uts(value: BigInt) {
    this.set("uts", Value.fromBigInt(value));
  }
}
